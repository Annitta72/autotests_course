# Напишите функцию multiplication_chain, которая принимает положительное число num,
# и возвращает количество раз count_multy, которое вы должны перемножить цифры числа num и полученных произведений,
# пока не получите одну цифру.
# Например (Ввод --> Вывод) :
#
# 39 --> 3 (потому что 3*9 = 27, 2*7 = 14, 1*4 = 4, вот 4 одна цифра. Итого 3 итерации)
# 999 --> 4 (потому что 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, наконец 1*2 = ,2 Итого 4 итерации)
# 4 --> 0 (4 уже одна цифра, а значит мы проделали 0 итераций)

def multiplication_chain(num):
    # Здесь нужно написать код
    # Создание переменных и присваивание значений
    # Счетчик итераций county_multy = 0, произведение = 1 (т.к. при умножении на 0 будет 0)
    count_multy, mult = 0, 1
    # Смена типа переменной на строку str()
    # Заполнение списка с перебором каждого элемента в строке (принятое число)
    num_lst = [int(a) for a in str(num)]
    # Цикл действий с условием пока длина списка не равна 1 (если список равен 1, то выходим из списка)
    while len(num_lst) != 1:
        count_multy += 1  # Увеличение счетчика итерации при каждом прохождении цикла
        # Перебор каждого элемента списка
        for x in range(len(num_lst)):
            mult *= num_lst[x]  # Перемножение каждого элемента списка на полученное произведение
        # Присваивание списку новых элементов с перебором элементов в строке (рассчитанное произведение за 1 итерацию)
        num_lst = [int(a) for a in str(mult)]
        mult = 1  # Сбрасываем произведение до начальных условий
    return count_multy

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = [
    39, 4, 25, 999, 5050, 222333444
]

test_data = [
    3, 0, 2, 4, 1, 4
]


for i, d in enumerate(data):
    assert multiplication_chain(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
